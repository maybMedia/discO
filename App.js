//bMay
//The main page for the discO song preference generator app. Provides users with an interface between their listening habits and the songs they want to listen to and discover by feeding them with potentially enjoyable songs for their taste.
//26/03/24

//The imported libraries used are below. This includes the built in libraries from React and Expo, along with the component library I used and the font.
import * as React from 'react';
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View, ImageBackground } from 'react-native';
import { PaperProvider } from 'react-native-paper';
import { useFonts, Gafata_400Regular } from '@expo-google-fonts/gafata';
import { Comfortaa_600SemiBold, Comfortaa_300Light } from '@expo-google-fonts/comfortaa';
import { Image } from 'expo-image';
import Toast from 'react-native-toast-message';
import axios from 'axios';
import * as AuthSession from "expo-auth-session";
import AsyncStorage from '@react-native-async-storage/async-storage';

//Imports for the components I made.
import ImageViewer from './components/ImageViewer';
import PrefButton from './components/PrefButton';
import SongProgress from './components/SongProgress';
import MediaControl from './components/MediaButton';

//Imports the spotify credentials necessary for interaction with the API
import { spotifyCredentials } from './secrets.js';
import { playlistCover } from './playlistCover.js';

//Import the specific components I need from the component library.
import { Icon, SegmentedButtons, Button } from 'react-native-paper';

const bg = require('./assets/background.svg'); //Loads the background from file.

//Gets the scopes for the Spotify API and concatenates them so they can be passed into the Access Token request.
const scopesArr = ['user-read-playback-state','user-modify-playback-state','user-read-currently-playing','streaming','app-remote-control','playlist-read-private','playlist-read-collaborative','playlist-modify-private','playlist-modify-public','user-read-playback-position','user-top-read','user-read-recently-played', 'ugc-image-upload',];
const scopes = scopesArr.join(' ');


//A function which takes in a length parameter. It generates a random code verifier of the specified length. It does so by appending a random character from the string of possible characters to the end of a string. Finally, that string is returned as the code verifier needed for Spotify authentication as a security measure.
function generateCodeVerifier(length) {
  let text = '';
  let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

  //Generates a random string of a specified length by iterating through a loop and appending a random character from the 'possible' set.
  for (let i = 0; i < length; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

//An asynchronous function which takes in a codeVerifier, generated by the above function, and encodes it using the 'TextEncoder' API. It then computes the SHA-256 hash of the data using a built in method. It convers the hash to a base64 string and replaces any '+' with '-' and any '/' with '_'. It removes any trailing = signs and returns the result.
async function generateCodeChallenge(codeVerifier) {
  const data = new TextEncoder().encode(codeVerifier);
  const digest = await window.crypto.subtle.digest('SHA-256', data);
  return btoa(String.fromCharCode.apply(null, [...new Uint8Array(digest)]))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '');
}

//A function which takes in a code(from the URL bar), and retrieves a code verifier from local storage. It then adds data to the search parameters of the browsers url which can be used by the authorisation request. Using the fetch API we make a 'POST' request to the Spotify API, passing in the params. If the auth request is unsuccessful, the function is called again. If it is successful it saves the access token for use in later requests.
async function generateAccessToken(code) {
  const verifier = localStorage.getItem("verifier");

  const params = new URLSearchParams();
  params.append("client_id", spotifyCredentials.clientId);
  params.append("grant_type", "authorization_code");
  params.append("code", code);
  params.append("redirect_uri", "http://localhost:8081/callback");
  params.append("code_verifier", verifier);

  const result = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: params
  });

  if (!result.ok) {
    getAuth();
    return null; // or throw an error
  }

  const { access_token } = await result.json();
  console.log(access_token);
  return access_token;
}

//A function with uses the above code verifier to generate a code of length 128. This is then stored in local storage. It then passes the necessary values into the params array and redirects the user to the Spotify login page with the parameters defined earlier.
async function getAuth () {
  const verifier = generateCodeVerifier(128);
  const challenge = await generateCodeChallenge(verifier);
  localStorage.setItem("verifier", verifier);

  const params = new URLSearchParams();
  params.append('client_id', spotifyCredentials.clientId);
  params.append('response_type', 'code');
  params.append("redirect_uri", "http://localhost:8081/callback");
  params.append("scope", scopes);
  params.append("code_challenge_method", "S256");
  params.append("code_challenge", challenge);

  document.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
}

//The program which is compiled and displayed by the browser or app view.
export default function App() {
  
  //Using react 'UseState' declare a variable for the access token which will be updated through the function 'setAccessToken()'.
  const [accessToken, setAccessToken] = React.useState('')

  //Retrieve the access token from the URL bar
  const params = new URLSearchParams(window.location.search);
  const code = params.get("code");
  // const [loggedIn, setLoggedIn] = React.useState(false);

  //This section only runs when the app is first loaded. or on the condition listed at the end.
  React.useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const code = params.get("code");
  
    //If a code is is found in the URL bar but there is no access token yet, generate one.
    if (code && !accessToken) {
      async function setToken(){
        setAccessToken(await generateAccessToken(code));
      }
      setToken();
    } else if (accessToken) {
      loadData(accessToken);
    }
  }, [accessToken]); //Runs whenever the access token changes.

  //Slices the givem string at the given length and adds an elipse to the end.
  function truncateString(string, length){
    return string.slice(0, length-1) + '...';
  }

  //A 'toast' to provide the user with feedback when a song is added to the disc0 playlist.
  const addedSongToast = (songTitle) => {
    Toast.show({
      type: 'success',
      text1: `Added ${songTitle} to the disc0 playlist!`,
      text2: 'Sounds groovy!'
    });
  }

  //A 'toast' to provide the user with feedback when there is an error with the preview audio of the song.
  const previewAudioErrorToast = (songTitle) => {
    Toast.show({
      type: 'error',
      text1: `'${truncateString(songTitle, 16)}' doesn't have a preview available!`,
      text2: 'Skip to the next song, or try again later!'
    });
  }

  //A function which retrieves the user profile from the Spotify API. Returns the data as a JSON file.
  async function fetchProfile(token) {
    const result = await fetch("https://api.spotify.com/v1/me", {
        method: "GET", headers: { Authorization: `Bearer ${token}` }
    });

    return await result.json();
  }

  //Defining of several 'states'. When these values are updated, the components involved are rerendered.
  const [recommendedTracks, setRecommendedTracks] = React.useState();
  const [Profile, setProfile] = React.useState();
  const [playbackStatus, setPlaybackStatus] = React.useState(false); //Initialises the React state for the current playback status
  const [segmentValue, setSegmentValue] = React.useState('home'); //Initialises the React state for the page which is visible
  const [songProgress, setSongProgress] = React.useState(0); //Initialises the React state for the progress completed by the song.
  const [albumImage, setAlbumImage] = React.useState('https://upload.wikimedia.org/wikipedia/en/3/3b/Dark_Side_of_the_Moon.png'); //Loads the placeholder album image from the web server.
  // const [volume, setVolume] = React.useState(0.5);
  const [trackIndex, setTrackIndex] = React.useState(0);
  const [audio, setAudio] = React.useState();
  const [track, setTrack] = React.useState();
  const [Disc0PlaylistList, setDisc0PlaylistList] = React.useState();


  //Initialises the font that we imported above
  let [fontsLoaded, fontError] = useFonts({
    Gafata_400Regular,
    Comfortaa_300Light,
    Comfortaa_600SemiBold,
  });

  //If no font loaded and there is no error message, do not display the app.
  if (!fontsLoaded && !fontError) {
    return null;
  }

  //Formats time from seconds, to minutes':'seconds.
  function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.round(seconds % 60);
    return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
  }

  //Grabs the profile image url from the profile JSON array and replaces the source of the default image with the profile image url.
  function populateProfile(profile){
    if (profile.images[0]) {
      const profileImage = new Image(200, 200);
      profileImage.src = profile.images[0].url;
      document.getElementById("profile").setAttribute("src", profileImage.src);
  }}

//An asynchronous function that fetches the top tracks from the Spotify API from the authenticated user. Using the fetch fucntion to send a 'GET' request to the spotify API with the accessToken as an authorization header.
//The time range parameter is set to 'short_term' which returns the top tracks from the last 4 weeks.
//If the response is not 'ok' it throws the error to the browser console.
//If it is successful it parse the response as JSON and logs it to the console and returns the ID's of the top three tracks.
async function getTopTrack(accessToken){
  const response = await fetch(`https://api.spotify.com/v1/me/top/tracks?time_range=short_term`, {
    method: 'GET',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json"
    }
  });

  if (!response.ok) {
    throw new Error("Failed to fetch top tracks");
  }

  const data = await response.json();
  console.log(data.items);
  console.log("Top Track:" + data.items[0].id);
  return data.items[0].id + ',' + data.items[1].id + ',' + data.items[2].id;
}

  //Fetches recommended tracks from the Spotify API. Given the accessToken, it will send a 'GET' request to the spotify API with the accessToken as an authorization header.
  //The request is sent with the track ID of three tracks to be used as 'seed' tracks, it will analyse them musically and compare with other spotify users listening to recommend new songs based on these tracks.
  //The response is parsed into a JSON form and the tracks are logged to the console and returned.
  async function getRecommendedTracks(accessToken) {
    const response = await fetch(`https://api.spotify.com/v1/recommendations?seed_tracks=${await getTopTrack(accessToken)}`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json"
      }
    });
  
    if (!response.ok) {
      throw new Error("Failed to fetch recommended tracks");
    }
  
    const data = await response.json();
    console.log(data.tracks);
    return data.tracks; // Assuming the API response contains a 'tracks' array of recommended tracks
  }

  // function setPlaybackVolume(volume){
  //   if(audio){
  //     audio.volume = volume;
  //     setVolume(volume);
  //   }
  // }

  //Skips the currently playing track.
  //Pauses the currently playing track, then increases the index of the track from the recTracks json file. Then repopulates the song data with the new index.
  async function nextTrack(accessToken){
    getTrackPreview('pauseSong', track);
    setTrackIndex(trackIndex + 1);
    populateSongData(recommendedTracks, trackIndex % 20); 
    if (trackIndex >= 20) {
      setRecommendedTracks(await getRecommendedTracks(accessToken), trackIndex);
      setTrackIndex(0);
    }
  }

  //A function which takes in two parameters, an instruction and a track. It first checks if the selected track exists and if it has a preview url. Depending on the instruction, it either plays the song, pauses the song or restarts the song. 
  function getTrackPreview(instruction, selectedTrack, accessToken){
    if (selectedTrack && selectedTrack.preview_url) {

      if(instruction === 'getSong'){
        const audio = new Audio(selectedTrack.preview_url);
        setAudio(audio);
        audio.volume = 0.5;
        audio.play();
        setPlaybackStatus(true);
      } else if(instruction === 'pauseSong'){
        audio.pause();
        setPlaybackStatus(false);
      } else if(instruction === 'playSong'){
        audio.play();
        setPlaybackStatus(true);
      } else if(instruction === 'restartSong'){
        audio.pause();
        audio.currentTime = 0;
        audio.play();
      }
      
      audio.addEventListener('play', () => {
        console.log('Audio is playing');
      });

      audio.addEventListener('pause', () => {
        console.log('Audio is paused');
      });

      audio.addEventListener('ended', () => {
        console.log('Playback ended');
        setPlaybackStatus(false);
      });

    } else {
      console.error("No preview available for the selected track");
      if (instruction === 'play' || instruction === 'getSong'){
        previewAudioErrorToast(selectedTrack.name);
      }
    }
  }

  //Takes in the array of tracks and the index of a track. Gets the track from the array based on the index and pulls all necessary data about the track. It then populates the data fields with the pulled data and plays the track preview audio.
  async function populateSongData(recTracks, track){
    if (!recTracks || recTracks.length === 0) {
      console.error("No tracks found");
    }

    const selectedTrack = recTracks[track];
    setTrack(selectedTrack);

    if (!selectedTrack) {
      console.error("No track selected");
    }

    const trackName = selectedTrack.name || "Unknown Track";
    const artistName = selectedTrack.artists && selectedTrack.artists.length > 0 ? selectedTrack.artists[0].name : "Unknown Artist";
    const albumName = selectedTrack.album ? selectedTrack.album.name : "Unknown Album";
    const albumImage = selectedTrack.album && selectedTrack.album.images && selectedTrack.album.images.length > 0 ? selectedTrack.album.images[0].url : "";
    const trackYear = selectedTrack.album.release_date ? selectedTrack.album.release_date.slice(0, 4) : "Unknown Year";
    const trackDuration = selectedTrack.duration_ms ? formatTime(selectedTrack.duration_ms / 1000) : 0;

    const songTitle = document.getElementById('title');
    const songArtist = document.getElementById('artist');
    const songAlbumName = document.getElementById('albumName');
    const songYear = document.getElementById('year');
    const songDuration = document.getElementById('duration');

    songTitle.textContent = trackName;
    songArtist.textContent = artistName;
    songAlbumName.textContent = albumName;
    songYear.textContent = trackYear;
    songDuration.textContent = trackDuration;
    setAlbumImage(albumImage);
    getTrackPreview('getSong', selectedTrack, accessToken);
  }

  //A function which takes in the accessToken. It gets the users profile, gets the users top tracks and populates the profile and top tracks fields with the pulled data.
  async function loadData(accessToken){
    // setAccessToken(await generateAccessToken(code));
    const profile = await fetchProfile(accessToken);
    setProfile(profile);
    console.log(profile);
    const recTracksReq = await getRecommendedTracks(accessToken);
    console.log(recTracksReq);
    setRecommendedTracks(recTracksReq);
    console.log("recommendedTracks: " + recommendedTracks);
    populateProfile(profile);
    populateSongData(recTracksReq, trackIndex);
  }

  //This function fetches a users playlist with the name 'disc0'. If it doesn't exist, it creates one.
  //It sends a "GET" request tot he Spotify API for all the users playlists. If it is successful it parses the response into JSON form and loops through each till it finds one with the name 'disc0'.
  //If it doesn't find it it creates one with the name 'disc0' and returns the id of the playlist.
  //Additionally, upon the creation of the playlist, it updates the playlists image with the base64 encoded JPEG given.
  async function fetchDisc0Playlist(accessToken, profile, ){
    const playlistResponse = await fetch(`https://api.spotify.com/v1/me/playlists`, {
      method: 'GET',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json"
      }
    });
  
    if (!playlistResponse.ok) {
      throw new Error("Failed to fetch top playlists!");
    }
  
    
    const playlistsResponse = await playlistResponse.json();
    const playlists = playlistsResponse.items;

    console.log(playlists);

    let playlistId;
    for (const playlist of playlists){
      if (playlist.name === 'disc0'){
        playlistId = playlist.id;
        console.log("Fount it! (The disc0 Playlist)")
      }
    }
    console.log('Playlist ID: ' + playlistId);

    if (!playlistId) {
        
        const response = await fetch(`https://api.spotify.com/v1/users/${profile.id}/playlists`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            "name": "disc0",
            "description": "A playlist curated by disc0!",
            "public": false
          })
        });
  
        if (!response.ok) {
          throw new Error("Could not create playlist!");
        }

        const responseData = await response.json();

        console.log('Created playlist');
        console.log(responseData);
        playlistId = responseData.id;

        await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/images`, {
          method: 'PUT',
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "image/jpeg",
          },
          body: playlistCover.encoded,
        });

    }

    return playlistId;
  }

  //This function remains unused. Though it does function.
  //Using the Spotify API, it sends a 'GET' request for the songs found in the 'disc0' playlist. It takes in the accessToken and profile as parameters.
  //It gets the 'disc0' playlist ID using the above function and then sends the 'GET' request. The response is then parsed as JSON and logged to the console. Additionally, the 'items' array is returned.
  async function getDisc0Songs(accessToken, profile){
    let playlistId = await fetchDisc0Playlist(accessToken, profile);

    const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=50`, {
      method: 'GET',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      }
    });

    if (!response.ok){
      throw new Error("Could not get songs from the disc0 playlist!");
    }

    const responseData = await response.json();
    console.log(responseData.items);
    return responseData.items;
  }

  //This function adds the selected song to the disc0 playlist.
  //It takes in the accessToken, trackUri, the users profile and the title of the song. The title of the song is only required for the user feedback.
  //First the above function is used to get the 'disc0' playlist ID. Then a 'POST' request is sent to the Spotify API with the track URI and the position of the track in the playlist. The response is then parsed as JSON and logged to the console.
  //The track is then skipped and the user is provided with a 'toast' to signify the process was successful.
  async function likeSong(accessToken, trackUri, profile, songTitle){

    let playlistId = await fetchDisc0Playlist(accessToken, profile)

    console.log(trackUri);

    const addResponse = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        "uris": [trackUri],
        "position": 0
      },)
    });

    if (!addResponse.ok) {
      throw new Error("Could not add track to playlist!");
    }

    console.log(addResponse);
    addedSongToast(songTitle);
    nextTrack(accessToken);
    return addResponse;
  }

  //
  //UNFINISHED
  //This function was intended to fill the 'disc0PlaylistList' with the songs from the disc0 playlist.
  //Currently loops infinitely without fulfilling the array

  // getDisc0Songs(accessToken, Profile)
  // .then((disc0Playlist) => {
  // const list = disc0Playlist.map((track) => (
  //   <li style={styles.playlistItem}>
  //     <img src={track.album?.images?.[0]?.url} style={styles.playlistAlbumImage}/>
  //     <View style={styles.playlistItemText}>
  //       <Text style={styles.playlistTrackTitle}>{track.name}</Text>
  //       <Text style={styles.playlistArtistName}>{track.artists}</Text>
  //     </View>
  //   </li>
  // ));
  // setDisc0PlaylistList(list);
  // })
  // .catch((error) => {
  //   console.error(error);
  // });
  
  //If the user is logged in, the code parameter will be set and the app will load. If not, the user will be prompted to log in.
  if (code){ 

    //Return the following 'HTML/React' to the browser.
    return (
      <PaperProvider>
        <ImageBackground source={bg} style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.pageTitle}>discOver</Text>
            {/* <SegmentedButtons
              style={styles.segmentSelector}
              value={segmentValue}
              onValueChange={setSegmentValue}
              density='medium'
              theme={{
                colors: {
                  secondaryContainer: '#E5F1FF'
                }
              }}
              buttons={[
                // {
                //   value:"social",
                //   //label: "Social",
                //   icon: "account-supervisor-circle",
                //   onPress: () => {console.log("Social Tab")},
                // },
                {
                  value:"home",
                  //label: "Discover",
                  icon: "music-circle-outline",
                  onPress: () => {console.log("Discover Tab")},
                },
                {
                  value:"profile",
                  //label: "You",
                  icon: 'face-man-profile',
                  onPress: () => {console.log("Your Profile Tab")},
                },
              ]}
            ></SegmentedButtons> */}
            <img src={''} id='profile' style={{width: 50, aspectRatio: 1, borderRadius: 100, margin: 2,}}></img>
          </View>

          <View style={styles.songDataContainer}>

            <ImageViewer id='album' imageSource={{uri: albumImage}} />
            
            {/* <input type="range" id="volumeSlider" min="0" max="1" step="0.1" defaultValue="0.5" onChange={() => {setPlaybackVolume(document.getElementById('volumeSlider').value);}}/> */}

            <Text id='title' style={styles.songTitle}>Money</Text>
            <Text id='artist' style={styles.songArtist}>Pink Floyd</Text>

            <View style={styles.songProgressContainer}>
              <SongProgress style={styles.songProgress} progress={songProgress} bgColor={'rgba(255, 255, 255, 0.25)'} fillColor={'#001A4B'}></SongProgress>
            </View>
            <View style={styles.songProgressLabels}>
              <Text id='songCompleted' style={styles.songProgText}>0:00</Text>
              <Text id='duration' style={styles.songProgText}>6:24</Text>
            </View>

            <View style={styles.statsContainer}>
              <View style={styles.infoContainer}>
                <Icon style={styles.statsIcon} color='#353535' size={20} source='album'></Icon>
                <Text id='albumName' style={styles.statsText}>The Dark Side Of The Moon</Text>
              </View>
              <View style={styles.infoContainer}>
                <Icon style={styles.statsIcon} color='#353535' size={20} source='calendar'></Icon>
                <Text id='year' style={styles.statsText}>1973</Text>
              </View>
            </View>

            <View style={styles.mediaControls}>
              <MediaControl icon={'step-backward-2'} onPress={() => getTrackPreview('restartSong', track)}></MediaControl>
              <MediaControl icon={playbackStatus ? 'pause' : 'play'} onPress={() => {
                playbackStatus ? getTrackPreview('pauseSong', track) : getTrackPreview('playSong', track)
              }}></MediaControl>
              <MediaControl icon={'step-forward'} onPress={() => nextTrack(accessToken)}></MediaControl>
            </View>

          </View>
          
          <View style={styles.buttonsContainer}>
            <View style={styles.buttonsRow}>

              <PrefButton start={{x: 0, y: 0}} end={{x: 1, y:1}} icon={'emoticon-sad'} onPress={() => nextTrack(accessToken)}></PrefButton>
              {/* <PrefButton start={{x: 0.5, y: 0}} end={{x: 0.5, y:1}} icon={'emoticon-neutral'} onPress={() => console.log('Pressed')}></PrefButton> */}
              <PrefButton start={{x: 1, y: 0}} end={{x: 0, y:1}} icon={'emoticon-happy'} onPress={() => likeSong(accessToken, track.uri, Profile, track.name)}></PrefButton>

            </View>
          </View>

          {/* <View style={styles.playlistContainer}>
            <Text style={styles.playlistTitle}>Your disc0veries</Text>
          
            <View style={styles.disc0Playlist}>
              
              

              <ul style={styles.playlistList}>
                {Disc0PlaylistList}
              </ul>
            </View>
          </View> */}

          <StatusBar style='auto'/>
        </ImageBackground>
        <Toast />
      </PaperProvider>
    );} else {

    //If not logged in, redirect to login poge.
    async function authenticate () {
      getAuth();
    }

    //Return this 'HTML/React' to the browser.
    return(
    <PaperProvider>
      <ImageBackground source={bg} style={styles.container}>
        <View style={styles.header}>
          <Text style={styles.pageTitle}>Login</Text>
        </View>
        <View style={styles.loginContainer}>
          <Icon source='spotify' size={96} color='#001A4B'></Icon>
          <Text style={styles.loginP}>Connect to <Text style={{color:'#1ED760', fontFamily: 'Comfortaa_600SemiBold'}}>Sp<Icon source='spotify' size={30} color='#1ED760'></Icon>tify</Text> to get started!</Text>
          <View style={{height: 80,}}/>
          <Button icon='spotify' mode='contained' textColor='#001A4B' buttonColor='#1ED760' onPress={authenticate} style={styles.loginButton}>Sign in with Spotify</Button>
        </View>
      </ImageBackground>
    </PaperProvider>
  )}
}


//The styles passed into the 'HTML/React' elements above.
const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 58,
    backgroundColor: '#25292e',
    alignItems: 'center',
    height: '100%',
  },
  songDataContainer: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.5)',
    borderRadius: 20,
    height: '70%',
    maxHeight: 560,
    width: '90%',
    maxWidth: 340,
    padding: 10,
    alignItems: 'center',
    // overflow: 'hidden',
  },
  buttonsContainer: {
    position: 'absolute',
    bottom: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.5)',
    borderRadius: 100,
    width: '90%',
    maxWidth: 340,
  },
  buttonsRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  songTitle: {
    width: '98%',
    textAlign: 'center',
    fontFamily: 'Gafata_400Regular',
    fontSize: 28,
    letterSpacing: 1,
    color: '#001A4B',
    padding: 5,
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
  },
  songArtist: {
    width: '98%',
    textAlign: 'center',
    fontFamily: 'Gafata_400Regular',
    fontSize: 20,
    letterSpacing: 0,
    color: '#353535',
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
  },
  songProgressContainer: {
    marginHorizontal: 'auto',
    marginTop: 20,
    marginBottom: 5,
    height: 2,
    width: '90%',
  },
  songProgress: {
    marginVertical: 20,
    width: '100%',
    backgroundColor: 'rgba(100, 100, 100, 0.5)',
  },
  songProgressLabels: {
    flexDirection: 'row',
    width: '90%',
    justifyContent: 'space-between',
  },
  songProgText: {
    fontFamily: 'Gafata_400Regular',
    fontSize: 12,
  },
  statsContainer: {
    width: '90%',
    margin: 10,
  },
  infoContainer: {
    flexDirection: 'row',
    justifyContent: 'left',
  },
  statsText: {
    marginLeft: 4,
    fontFamily: 'Gafata_400Regular',
    fontSize: 16,
    width: '98%',
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
  },
  mediaControls: {
    flexDirection: 'row',
    marginHorizontal: 'auto',
  },
  header: {
    width: '85%',
    maxWidth: 320,
    justifyContent: 'space-between',
    flexDirection: 'row',
    alignItems: 'center',
  },
  pageTitle: {
    fontFamily: 'Gafata_400Regular',
    fontSize: 42,
    color: '#ffffff',
    textAlign: 'left',
    width: '50%',
  },
  segmentSelector: {
    width: '50%',
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
    borderRadius: 50,
    height: 30,
    marginLeft: 5,
  },
  loginContainer: {
    height: '80%',
    backgroundColor: 'rgba(255, 255, 255, 0.5)',
    width: '80%',
    margin: 10,
    borderRadius: 20,
    maxHeight: 560,
    maxWidth: 340,
    alignItems: 'center',
    padding: 20,
  },
  loginP: {
    fontFamily: 'Comfortaa_300Light',
    fontSize: 42,
    color: '#001A4B',
    textAlign: 'center',
    margin: 20,
  },
  loginButton: {
    width: '90%',
    height: 42,
    justifyContent: 'center',
  },
  disc0Playlist: {
    backgroundColor: 'rgba(255, 255, 255, 0.5)',
    borderRadius: 20,
    height: '100%',
    width: '98%',
  },
  playlistContainer: {
    position: 'absolute',
    right: '10%',
    flex: 1,
    height: '91%',
    maxHeight: 1440,
    width: '90%',
    maxWidth: 340,
    padding: 10,
    alignItems: 'center',
  },
  playlistTitle: {
    alignContent: 'left',
    fontFamily: 'Gafata_400Regular',
    fontSize: 28,
    color: '#ffffff',
    textAlign: 'left',
    width: '100%',
    paddingBottom: 10,
  },
  playlistList: {
    width: '90%',
    height: '98%',
    overflow: 'hidden',    
    listStyle: 'none',
    alignItems: 'center',
  },
  playlistItem: {
    width: '90%',
    height: 100,
    display: 'flex',
  },
  playlistAlbumImage: {
    width: 80,
    height: 80,
    paddingRight: 10,
  },
  playlistItemText: {
    display: 'flex',
    flexDirection: 'column',
    width: '98%',
    textAlign: 'left',
    fontFamily: 'Gafata_400Regular',
    letterSpacing: 1,
    paddingTop: 10,
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
  },
  playlistTrackTitle: {
    fontSize: 22,
    color: '#001A4B',
  },
  playlistArtistName: {
    fontSize: 18,
    color: '#353535',
  },
});
